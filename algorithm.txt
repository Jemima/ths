Data Structures:
==
General structure:
Blif represents a BLIF file, contains 1+ Models
Model represents a BLIF model, or circuit, as a DFG.
Each node is a BlifNode.
Each BlifNode has the names of its inputs and outputs stored as strings.
The model contains a map from string->Signal.
Each Signal has a pointer to source and sinks.

signals[node->output]->sinks are the children of a node
FOREACH(signal) in inputs
   signals[signal]->source
provides the ancestors of each node.
A Model also contains the primary input and output signals.

Storing signals as names, and providing a circuit specific map allows for nodes
to be copied directly across with redirecting pointers at each step.
Additionally, it means cutting loops is a simple case of string replacement,
as the list of signals is dynamically generated from the set of nodes.

Model: Represents a BLIF Model i.e. a circuit or subcircuit within a BLIF file
as a DFG.
Fields:
   set(BlifNode) nodes - The set of all circuit elements
   map(string->Signal) - a map from signal name to signal
   string name - The name of this model
   list(Signal) inputs - The list of primary inputs for this circuit
   list(Signal) outputs - The list of primary outputs for this circuit

Methods:
   CutLoops() - described at ...
   AddNode(BlifNode) - adds a BlifNode to the current circuit. Doesn't create
   necessary signals.
   MakeSignalList() - Creates all appropriate signals
   MakeIOList() - Promotes appropriate signals to primary innputs or outputs

BlifNode: Represents a circuit element, or node within the DFG representing
our circuit
   List(string) inputs - names of input signals
   string output - name of output signal
   string clock - name of clock signal (if applicable)
   string type - ".latch" or ".names" for latch or LUT
   string contents - body of node element. Type dependent text data.
   unsigned long id - Unique id
   unsigned cost - 0 for LUT, 1 for latch. Number of clock cycles added to
   critical path by this node.
Methods:
   MakeNode(string type, list(string) params) - Creates a BlifNode from the
   text data in a BLIF file
   AddContents(string line) - Adds the provided line to the node body
   GetText() - Returns a textual representation for the node, suitable to be
   inserted into a BLIF file
   Clone() - Creates a clone of this node






Signal: Represents a signal between nodes, or a set of edges with common
source from a node in the DFG.
Fields:
   string name - name of the signal
   BlifNode source - node which drives this signal
   List(BlifNode) sinks - nodes which this signal drives

Blif: Represents a BLIF file, providing helper methods to read a file into a
model.
Fields:
   Map(string->Model) models - Map from model name to model
   List(string) masterInputs - Primary inputs for the master circuit
   List(string) masterOutputs - Primary inputs for the master circuit
   Model main - Master circuit model
Methods:
   Blif(string path) - Constructor, create Blif object from path to a BLIF
   file
   Write(string path, Model model) - Writes the specified model to a BLIF file







Algorithm:
==
      BEGIN main(input, targetRecoveryTime)
         Returns:
            Blif file containing transformed input file
         Variables:
            input - path to input blif file
            output - path to output blif file
            files - set of paths to blif files representing partitions
            file - path to intermediate blif file
         files <- Partition(input)
         FOREACH(file in files)
            file <- Triplicate(input)
         header <- input->GetLines(3) //Read the first three lines (name, inputs, outputs)
         file <- Join(files, header)
         output <- Flatten(output)
      END main

Given an input blif file (input), partition it into a separate file for each
partition, triplicate each file, join them together into one heirarchical
file, then flatten it back down.

      BEGIN Partition(file, targetRecoveryTime)
         Returns:
            Set of files containing partitions
         Variables:
            file - path to input blif file
            targetRecoveryTime - time (in seconds)
            circuit - BlifModel representing a circuit
            queue - FIFO queue
            visited - map of whether a node has been visited
            signal - Signal
            node - BlifNode
            numPartitions - counter for the number of partitions
            outPath - string representing output path
            files - set of files containing partitions

         circuit <- BlifModel.FromFile(file)
         partition <- BlifModel.EmptyCircuit()
         queue <- Queue.EmptyQueue()
         visited <- Map(BlifNode->bool, DEFAULT: false)
         targetRecoveryTime

         FOREACH(signal in circuit->outputs)
            queue->Enqueue(signal->source)

         WHILE(queue->Size > 0)
            node = queue->Dequeue();
            IF(visited[node] == true)
               continue
            visited[node] = true
            IF(RecoveryTime(partition, node) > targetRecoveryTime)
               partition->CutLoops()
               files <- files+partition->WriteToFile()
               numPartitions <- numPartitions+1
               partition <- BlifModel.EmptyCircuit()
            FOREACH(signal in node->inputs)
               queue.Enqueue(signal->source)

         IF(partition->Size() > 0)
            files <- files+partition->WriteToFile()
         return files
      END Partition
Iterate through the nodes in a circuit, adding them to partitions such that
each partition is under a specified recovery time.

      BEGIN RecoveryTime(partition, node)
         return function which is not currently specified
      END RecoveryTime
Fill this in once RecoveryTime calculation is implemented.

      BEGIN BlifModel->CutLoops()
         Variables:
            state - Map from node to whether it's explored or not
         
         state <- Map(BlifNode->int, DEFAULT: 0)
         FOREACH(signal in this->outputs)
            this->CutLoopsRecursive(state, NULL, signal)
      END BlifModel->CutLoops

      BEGIN BlifModel->CutLoopsRecursive(state, parent, signal)
         Variables:
            state - map of whether a node is explored or not
            node - BlifNode
            parent - parent node
            signal - edge into this node
            sig - temp signal
         Constants:
            NEW - 0
            EXPLORING - 1
            FINISHED - 2
         node = signal->source
         IF(state[node] == EXPLORING) //Found a cycle
            ReplaceSignalName(parent->inputs, signal->name, "qqrin"+signal->name)
         ELSEIF(state[node] == FINISHED) //Already explored this path
            return;
         ELSE
            state[node] = EXPLORING
            FOREACH(sig in node->inputs)
               this->CutLoopsRecursive(state, node, signal)

         state[node] = FINISHED
      END BlifModel->CutLoopsRecursive

      BEGIN ReplaceSignalName(signals, name, newName)
         Variables:
            signals - set of signals
            name - string to search for
            newName - string to replace name with
            signal - temp Signal

         FOREACH(signal in signals)
            IF(signal->name == name)
               signal->name = newName
      END ReplaceSignalName

      BEGIN Triplicate(file)
         Variables:
            voter - string containing blif voter circuit
            file - string containing path to input file
            circuit - string containing blif circuit
            output - output circuit
            subckt - string representing subcircuit text for blif file
            inputs - array of input names
            outputs - array of output names
            name - string containing circuit name
            str - temporary string variable
            n - temporary integer counter

         voter <- "voter.blif"->GetContents()
         name <- ParseLine(file->GetNextLine())
         inputs <- ParseLine(file->GetNextLine())
         outputs <- ParseLine(file->GetNextLine())
         file->seek(0)
         circuit <- file->GetContents()
         output->write(".model output\n")
         output->write(".inputs "+inputs+"\n")
         output->write(".outputs "+outputs+"\n")

         subckt <- "\n.subckt "+name
         FOREACH(str in inputs)
             subckt <- subckt + " " + str + "=" + str
         n <- 0
         FOREACH(str in outputs)
            subckt <- subckt + " " + str + "=" + "qq" + n + "//replace"
            n <- n+1
         subckt <- subckt->replace("=qqrin", "=")

         output->write(subckt->replace("//replace", '0'))
         output->write(subckt->replace("//replace", '1'))
         output->write(subckt->replace("//replace", '2'))

         n <- 0
         FOREACH(str in outputs)
            output->write("\n.subckt voter a=qq"+n+"0 b=qq"+n+"1 c=qq"+n+"2
            out="str)
            n <- n+1

         output->write(voter)
         output->write(circuit)
         return output
      END Triplicate
file->GetNextLine reads the next line from the file. Note that lines may be
continued according to the blif specification by ending the line with a '\'
file->GetContents returns the entire contents of the file.
This probably needs to be tidied up. Sort out exactly how much detail to go
into. I suspect this would be better represented graphically.
Basically, given a voter and a circuit, embed both as subcircuits into a new
heirarchical blif file, create three instances of the circuit and one of the
voter, and connect each set of three corresponding outputs to one voter, to
the single corresponding overall output.

      BEGIN Join(files, header)
         Variables:
            
         output->write(header)
         tail <- ""
         count <- 0
         FOREACH(file in files)
            name <- ParseLine(file->GetNextLine())
            inputs <- ParseLine(file->GetNextLine())
            outputs <- ParseLine(file->GetNextLine())
            prefix <- "p"+count
            file->seek(0)
            circuit <- file->GetContents()
            subckt <- ".subckt "+prefix+name
            FOREACH(str in inputs)
               subckt <- subckt + str + "=" + str
            FOREACH(str in outputs)
               subckt <- subckt + str + "=" + str
            circuit->replace(".model ", ".model "+prefix)
            circuit->replace(".subckt ", ".subckt "+prefix)
            tail <- tail+circuit
            output->write(subckt)
            count <- count+1

         output->write(tail)

         return output
      END Join
Given a list of blif files, concatenates them all together, creates
subcircuit definitions to connect them all together, and writes them to a file

      BEGIN Flatten(file)
         Flattening is currently performed by abc (link), called with parameters:
         ./abc -o output -c echo file
         Due to bug in abc, clock information is stripped from latches, so we then
         called grep and sed to fix the output file
         latch = split(grep -m 1 '\.latch' file)
         IF(latch)
            sed -ri 's/\.latch.+)(2)/\1 '+latch[3] + ' ' + latch[4] + ' 2/' output
      END Flatten(file)
./abc is provided an input file, given the command to echo the current file,
and told to output everything to output
grep is called to search for latches, and return the latch information if
there is one. If there is, replace the faulty latch information with the
correct information.
This assumes that there is only one global clock, all latches are triggered on
the same signal (e.g. rising edge, falling etc), and all latches have initial
state don't care, which holds true for all provided benchmarks.
