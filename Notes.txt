
Create empty graph (main).
Iterate through blif file. For each element in the file, insert it as a new node in our DFG.
Create primary inputs and outputs for the main graph.

Create empty graph (working).
Starting at the main graph's outputs, add nodes to FIFO queue.
Iterate through queue, pop node each time.
If node has already been visited move onto the next.
Mark node as visited.
Calculate recovery time for graph, if node were added. -> function of number of nodes, clock period (assumed constant) and critical path length (updated on node insertion)
If recovery time exceeds limit then:
   traverse graph recursively to cut loops
   promote every node output as a primary output, and every undriven signal as a primary input
   export graph to file in blif format
   initialise a new empty graph
Copy node and add it to graph.
Update critical path length AKA clock steps AKA latency.
Repeat until queue empty
export current partition

Read in every partition as a black box and triplicate.
Add voter black box.
Rejoin cut loops.
Export to file.

Join each triplicated black box into one large heirarchical blif file.

Flatten blif file.